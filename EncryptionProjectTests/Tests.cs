using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using EncryptionProject;
using Microsoft.QualityTools.Testing.Fakes;
using EncryptionProject.Fakes;

namespace EncryptionProjectTests
{
    [TestClass]
    public class Tests
    {
        [TestMethod]
        public void TestEncrypt1()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "12345678";      //stores the encryption key used in this test

            string expectedEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedEncryptedSample1.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                    GetDecryptedFileName = () => { return decryptedFileName; },
                    GetEncryptedFileName = () => { return encryptedFileName; },
                    GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncryptFurther1()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "12345678";      //stores the encryption key used in this test

            string expectedFurtherEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedFurtherEncryptedSample1.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.EncryptFurther(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedFurtherEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestDecrypt1()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "12345678";      //stores the encryption key used in this test

            string expectedDecryptedText = System.IO.File.ReadAllText(decryptedFileName);     //store the expected value for the decrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };


                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCiphr instance

                //Act:
                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test
                //Here, Encrypt() is also called to make sure that an encrypted text file exists

                string decryptedText = cipher.Decrypt(encParams);       //call Decrypt() and pass the stub encParams to make sure the desired file names and encryption key are passed in for this test
                //the decrypted text returned by Decrypt() is stored in a string to be used for testing

                //Assert:
                Assert.AreEqual(expectedDecryptedText, decryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncrypt2()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "abcdefgh";      //stores the encryption key used in this test

            string expectedEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedEncryptedSample2.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncryptFurther2()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "abcdefgh";      //stores the encryption key used in this test

            string expectedFurtherEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedFurtherEncryptedSample2.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.EncryptFurther(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedFurtherEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestDecrypt2()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "abcdefgh";      //stores the encryption key used in this test

            string expectedDecryptedText = System.IO.File.ReadAllText(decryptedFileName);     //store the expected value for the decrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };


                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCiphr instance

                //Act:
                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test
                //Here, Encrypt() is also called to make sure that an encrypted text file exists

                string decryptedText = cipher.Decrypt(encParams);       //call Decrypt() and pass the stub encParams to make sure the desired file names and encryption key are passed in for this test
                //the decrypted text returned by Decrypt() is stored in a string to be used for testing

                //Assert:
                Assert.AreEqual(expectedDecryptedText, decryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncrypt3()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "a2h;]^%#";      //stores the encryption key used in this test

            string expectedEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedEncryptedSample3.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncryptFurther3()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "a2h;]^%#";      //stores the encryption key used in this test

            string expectedFurtherEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedFurtherEncryptedSample3.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.EncryptFurther(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedFurtherEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestDecrypt3()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "a2h;]^%#";      //stores the encryption key used in this test

            string expectedDecryptedText = System.IO.File.ReadAllText(decryptedFileName);     //store the expected value for the decrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };


                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCiphr instance

                //Act:
                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test
                //Here, Encrypt() is also called to make sure that an encrypted text file exists

                string decryptedText = cipher.Decrypt(encParams);       //call Decrypt() and pass the stub encParams to make sure the desired file names and encryption key are passed in for this test
                //the decrypted text returned by Decrypt() is stored in a string to be used for testing

                //Assert:
                Assert.AreEqual(expectedDecryptedText, decryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncrypt4()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "[2f;’1/,";      //stores the encryption key used in this test

            string expectedEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedEncryptedSample4.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncryptFurther4()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "[2f;’1/,";      //stores the encryption key used in this test

            string expectedFurtherEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedFurtherEncryptedSample4.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.EncryptFurther(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedFurtherEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestDecrypt4()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "[2f;’1/,";      //stores the encryption key used in this test

            string expectedDecryptedText = System.IO.File.ReadAllText(decryptedFileName);     //store the expected value for the decrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };


                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCiphr instance

                //Act:
                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test
                //Here, Encrypt() is also called to make sure that an encrypted text file exists

                string decryptedText = cipher.Decrypt(encParams);       //call Decrypt() and pass the stub encParams to make sure the desired file names and encryption key are passed in for this test
                //the decrypted text returned by Decrypt() is stored in a string to be used for testing

                //Assert:
                Assert.AreEqual(expectedDecryptedText, decryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncrypt5()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "@$#&*%^!";      //stores the encryption key used in this test

            string expectedEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedEncryptedSample5.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestEncryptFurther5()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "@$#&*%^!";      //stores the encryption key used in this test

            string expectedFurtherEncryptedText = System.IO.File.ReadAllText("C:\\Deep\\School CS Projects\\expectedFurtherEncryptedSample5.txt");     //store the expected value for the encrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };

                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCipher instance

                //Act:

                cipher.EncryptFurther(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test

                string encryptedText = System.IO.File.ReadAllText(encryptedFileName);       //read the text encrypted by Encrypt()

                //Assert:
                Assert.AreEqual(expectedFurtherEncryptedText, encryptedText);      //test if the expected and actual values are equal
            }
        }

        [TestMethod]
        public void TestDecrypt5()
        {
            //Arrange:

            string decryptedFileName = "C:\\Deep\\School CS Projects\\sample.txt";      //stores the file address for the decrypted or original text file
            string encryptedFileName = "C:\\Deep\\School CS Projects\\encryptedSample.txt";     //stores the file address for the encrypted text
            string encryptionKey = "@$#&*%^!";      //stores the encryption key used in this test

            string expectedDecryptedText = System.IO.File.ReadAllText(decryptedFileName);     //store the expected value for the decrypted text

            //create a fake IEncryptionParameters to handle and give in the required and desired inputs for this test
            //for this, a stub is used
            IEncryptionParameters encParams =
                 new EncryptionProject.Fakes.StubIEncryptionParameters() //generated by Fakes
                 {
                     GetDecryptedFileName = () => { return decryptedFileName; },
                     GetEncryptedFileName = () => { return encryptedFileName; },
                     GetEncryptionKey = () => { return encryptionKey; }
                 };

            //since for the test we are using a particular key and not a randomly generated key for encryption,
            //a fake shim is used to detour the GenerateKey method and add different code to simply return the required desired encryption key for this test above
            using (ShimsContext.Create())
            {
                //Detour GenerateKey to return a fixed encryption key
                EncryptionProject.Fakes.ShimOffsetCipher.AllInstances.GenerateKey = (OffsetCipher) => { return encryptionKey; };


                OffsetCipher cipher = new OffsetCipher();       //create an OffsetCiphr instance

                //Act:
                cipher.Encrypt(encParams);      //call Encrypt() and pass the stub encParams to make sure the desired file names are returned for this test
                //Here, Encrypt() is also called to make sure that an encrypted text file exists

                string decryptedText = cipher.Decrypt(encParams);       //call Decrypt() and pass the stub encParams to make sure the desired file names and encryption key are passed in for this test
                //the decrypted text returned by Decrypt() is stored in a string to be used for testing

                //Assert:
                Assert.AreEqual(expectedDecryptedText, decryptedText);      //test if the expected and actual values are equal
            }
        }
    }
}
